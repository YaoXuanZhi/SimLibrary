/*****************************************************************************
*  @file     CShellChangeWatcher.h
*  @brief    文件夹变动监控库
*  @note
*  在这里，所用到的Win32 API其实已经在高版本的VS之中其实已经支持了
*  不过，由于个人的原因，因此需要在VC 6.0下编译它，编写了一个类来
*  动态调用所有可能用到的API，注意，由于SHGetPathFromIDList等系列
*  API是自Win Xp才开始支持的，至于SHChangeNotifyRegister和
*  SHChangeNotifyDeregister这两个API则是Windows 2000就开始支持的Win32 API
*  因此注意其调用环境哦^_^。
*
*****************************************************************************/
#ifndef __CSHELLCHANGEWATCHER_H
#define __CSHELLCHANGEWATCHER_H

#include <windows.h>
#include <Shlobj.h>
#include <tchar.h>

#ifndef SHCNRF_InterruptLevelPLUS
#define SHCNRF_InterruptLevelPLUS 0x0001 //Interrupt level notifications from the file system
#endif

#ifndef SHCNRF_ShellLevelPLUS
#define SHCNRF_ShellLevelPLUS   0x0002 //Shell-level notifications from the shell
#endif

#ifndef SHCNRF_RecursiveInterruptPLUS
#define SHCNRF_RecursiveInterruptPLUS 0x1000 //Interrupt events on the whole subtree
#endif

#ifndef SHCNRF_NewDeliveryPLUS
#define SHCNRF_NewDeliveryPLUS   0x8000 //Messages received use shared memory
#endif

#ifndef SHCNE_RENAMEITEMPLUS
#define SHCNE_RENAMEITEMPLUS          0x00000001L
#endif

#ifndef SHCNE_CREATEPLUS
#define SHCNE_CREATEPLUS              0x00000002L
#endif

#ifndef SHCNE_DELETEPLUS
#define SHCNE_DELETEPLUS              0x00000004L
#endif

#ifndef SHCNE_MKDIRPLUS
#define SHCNE_MKDIRPLUS               0x00000008L
#endif

#ifndef SHCNE_RMDIRPLUS
#define SHCNE_RMDIRPLUS               0x00000010L
#endif

#ifndef SHCNE_MEDIAINSERTEDPLUS
#define SHCNE_MEDIAINSERTEDPLUS       0x00000020L
#endif

#ifndef SHCNE_MEDIAREMOVEDPLUS
#define SHCNE_MEDIAREMOVEDPLUS        0x00000040L
#endif

#ifndef SHCNE_DRIVEREMOVEDPLUS
#define SHCNE_DRIVEREMOVEDPLUS        0x00000080L
#endif

#ifndef SHCNE_DRIVEADDPLUS
#define SHCNE_DRIVEADDPLUS            0x00000100L
#endif

#ifndef SHCNE_NETSHAREPLUS
#define SHCNE_NETSHAREPLUS            0x00000200L
#endif

#ifndef SHCNE_NETUNSHAREPLUS
#define SHCNE_NETUNSHAREPLUS          0x00000400L
#endif

#ifndef SHCNE_ATTRIBUTESPLUS
#define SHCNE_ATTRIBUTESPLUS          0x00000800L
#endif

#ifndef SHCNE_UPDATEDIRPLUS
#define SHCNE_UPDATEDIRPLUS           0x00001000L
#endif

#ifndef SHCNE_UPDATEITEMPLUS
#define SHCNE_UPDATEITEMPLUS          0x00002000L
#endif

#ifndef SHCNE_SERVERDISCONNECTPLUS
#define SHCNE_SERVERDISCONNECTPLUS    0x00004000L
#endif

#ifndef SHCNE_UPDATEIMAGEPLUS
#define SHCNE_UPDATEIMAGEPLUS         0x00008000L
#endif

#ifndef SHCNE_DRIVEADDGUIPLUS
#define SHCNE_DRIVEADDGUIPLUS         0x00010000L
#endif

#ifndef SHCNE_RENAMEFOLDERPLUS
#define SHCNE_RENAMEFOLDERPLUS        0x00020000L
#endif

#ifndef SHCNE_FREESPACEPLUS
#define SHCNE_FREESPACEPLUS           0x00040000L
#endif

// SHCNE_EXTENDED_EVENT: the extended event is identified in dwItem1,
// packed in LPITEMIDLIST format (same as SHCNF_DWORD packing).
// Additional information can be passed in the dwItem2 parameter
// of SHChangeNotify (called "pidl2" below), which if present, must also
// be in LPITEMIDLIST format.
//
// Unlike the standard events, the extended events are ORDINALs, so we
// don't run out of bits.  Extended events follow the SHCNEE_* naming
// convention.
//
// The dwItem2 parameter varies according to the extended event.
#ifndef SHCNE_EXTENDED_EVENTPLUS
#define SHCNE_EXTENDED_EVENTPLUS      0x04000000L
#endif

#ifndef SHCNE_ASSOCCHANGEDPLUS
#define SHCNE_ASSOCCHANGEDPLUS        0x08000000L
#endif

#ifndef SHCNE_DISKEVENTSPLUS
#define SHCNE_DISKEVENTSPLUS          0x0002381FL
#endif

#ifndef SHCNE_GLOBALEVENTSPLUS
#define SHCNE_GLOBALEVENTSPLUS        0x0C0581E0L // Events that dont match pidls first
#endif

#ifndef SHCNE_ALLEVENTSPLUS
#define SHCNE_ALLEVENTSPLUS           0x7FFFFFFFL
#endif

#ifndef SHCNE_INTERRUPTPLUS
#define SHCNE_INTERRUPTPLUS           0x80000000L // The presence of this flag indicates
#endif
// that the event was generated by an
// interrupt.  It is stripped out before
// the clients of SHCNNotify_ see it.

// SHCNE_EXTENDED_EVENT extended events.  These events are ordinals.
// This is not a bitfield.

#ifndef SHCNEE_ORDERCHANGEDPLUS
#define SHCNEE_ORDERCHANGEDPLUS             2L  // pidl2 is the changed folder
#endif

#ifndef SHCNEE_MSI_CHANGEPLUS
#define SHCNEE_MSI_CHANGEPLUS               4L  // pidl2 is a SHChangeProductKeyAsIDList
#endif

#ifndef SHCNEE_MSI_UNINSTALLPLUS
#define SHCNEE_MSI_UNINSTALLPLUS            5L  // pidl2 is a SHChangeProductKeyAsIDList
#endif


#ifndef ARRAYSIZE
#define  ARRAYSIZE(a) (sizeof((a))/sizeof((a[0])))
#endif

typedef ITEMIDLIST *LPCITEMIDLISTPLUS;
typedef ITEMIDLIST *LPITEMIDLISTPLUS;

typedef LPITEMIDLISTPLUS PIDLIST_ABSOLUTEPLUG;

#ifndef PCIDLIST_ABSOLUTEPLUS
#define PCIDLIST_ABSOLUTEPLUS        LPCITEMIDLISTPLUS
#endif

typedef struct
{
    LPCITEMIDLISTPLUS pidl; //Pointer to an item identifier list (PIDL) for which to receive notifications
    BOOL fRecursive; //Flag indicating whether to post notifications for children of this PIDL
}SHChangeNotifyEntryPlus;

typedef ULONG(WINAPI* pfnSHChangeNotifyRegister)(HWND hWnd, int fSource, LONG fEvents, UINT wMsg, int cEntries, const SHChangeNotifyEntryPlus* pfsne);
typedef BOOL (WINAPI* pfnSHChangeNotifyDeregister)(ULONG ulID);
typedef HANDLE  (WINAPI* pfnSHChangeNotification_Lock)(HANDLE hChange, DWORD dwProcId, PIDLIST_ABSOLUTEPLUG **pppidl, LONG *plEvent);
typedef BOOL(WINAPI* pfnSHChangeNotification_Unlock)(HANDLE hLock);
typedef HRESULT(WINAPI* pfnSHGetSpecialFolderLocation)(HWND hwnd, int csidl, PIDLIST_ABSOLUTEPLUG *ppidl);
typedef BOOL(WINAPI* pfnSHGetPathFromIDListW)(LPCITEMIDLISTPLUS pidl, LPWSTR pszPath);
typedef BOOL(WINAPI* pfnSHGetPathFromIDListA)(LPCITEMIDLISTPLUS pidl, LPSTR pszPath);
typedef PIDLIST_ABSOLUTEPLUG(WINAPI* pfnSHSimpleIDListFromPath)(PCWSTR pszPath);

class SHChangeNotifyDLL
{
private:
	pfnSHChangeNotifyDeregister m_pfnChangeNotifyDeregister;
	pfnSHChangeNotifyRegister m_pfnSHChangeNotifyRegister;
	pfnSHGetSpecialFolderLocation m_pfnGetSpecialFolderLocation;
	pfnSHGetPathFromIDListW m_pfnGetPathFromIDListW;
	pfnSHGetPathFromIDListA m_pfnGetPathFromIDListA;
	pfnSHChangeNotification_Lock m_pfnChangeNotification_Lock;
	pfnSHChangeNotification_Unlock m_pfnChangeNotification_Unlock;
	pfnSHSimpleIDListFromPath m_pfnSimpleIDListFromPath;
	HMODULE m_hShell32;

private:
	SHChangeNotifyDLL();

public:
	static SHChangeNotifyDLL &GetInstance();

	BOOL SHChangeNotifyDeregister(ULONG ulID);

	ULONG SHChangeNotifyRegister(HWND hWnd,
		int fSource,
		LONG fEvents,
		UINT wMsg,
		int cEntries,
		const SHChangeNotifyEntryPlus *pfsne
		);

	HRESULT SHGetSpecialFolderLocation(HWND hwnd, 
		int csidl, 
		PIDLIST_ABSOLUTEPLUG *ppidl);

	BOOL SHGetPathFromIDListW(LPCITEMIDLISTPLUS pidl, LPWSTR pszPath);
	BOOL SHGetPathFromIDListA(LPCITEMIDLISTPLUS pidl, LPSTR pszPath);
	BOOL SHGetPathFromIDListT(LPCITEMIDLISTPLUS pidl, LPTSTR pszPath);

	HANDLE SHChangeNotification_Lock(HANDLE hChange, 
		DWORD dwProcId, 
		PIDLIST_ABSOLUTEPLUG **pppidl, 
		LONG *plEvent);
	BOOL SHChangeNotification_Unlock(HANDLE hLock);

	PIDLIST_ABSOLUTEPLUG SHSimpleIDListFromPath(PCWSTR pszPath);
	
};

class CShellItemChangeWatcher
{
public:
	CShellItemChangeWatcher();
	~CShellItemChangeWatcher();
	HRESULT StartWatching(HWND hwnd, UINT uMsg, long lEvents, BOOL fRecursive);
	void StopWatching();
	void OnChangeMessage(WPARAM wParam, LPARAM lParam);

protected:
	TCHAR* PrintEventName(long lEvent);
	void PrintPidlInfo(PIDLIST_ABSOLUTEPLUG pidl);
	bool IsItemNotificationEvent(long lEvent);

private:
	ULONG _ulRegister;
};

#endif

/*********************************调用演示************************************
CShellItemChangeWatcher g_Watcher;

#ifndef WS_NOTIFYMESSAGE
#define WS_NOTIFYMESSAGE WM_USER + 200
#endif

LRESULT CALLBACK WndProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uiMsg)
	{
	case WM_CREATE:
	{
		g_Watcher.StartWatching(hwnd, WS_NOTIFYMESSAGE, SHCNE_ALLEVENTSPLUS, true);
	}; break;
	case WS_NOTIFYMESSAGE:
	{
		g_Watcher.OnChangeMessage(wParam, lParam);
	}; break;
	case WM_DESTROY:
	{
		PostQuitMessage(0);
	}; break;
	}
	return DefWindowProc(hwnd, uiMsg, wParam, lParam);
}

int APIENTRY _tWinMain(HINSTANCE hInstance,
	HINSTANCE hPrevInstance,
	LPTSTR    lpCmdLine,
	int       nCmdShow)
{
	TCHAR *szWndClassName = _T("SHChangeNotifyWnd");

	WNDCLASSEX wcex;
	wcex.cbSize = sizeof(WNDCLASSEX);
	wcex.style = CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc = WndProc;
	wcex.cbClsExtra = 0;
	wcex.cbWndExtra = 0;
	wcex.hInstance = hInstance;
	wcex.hIcon = NULL;
	wcex.hCursor = LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	wcex.lpszMenuName = NULL;
	wcex.lpszClassName = szWndClassName;
	wcex.hIconSm = NULL;
	RegisterClassEx(&wcex);

	HWND hwnd = CreateWindow(
		szWndClassName,
		_T("Demo"),
		WS_OVERLAPPEDWINDOW | WS_VISIBLE,
		CW_USEDEFAULT, CW_USEDEFAULT,
		CW_USEDEFAULT, CW_USEDEFAULT,
		NULL,
		NULL,
		hInstance,
		0);

	ShowWindow(hwnd, nCmdShow);
	UpdateWindow(hwnd);

	MSG msg;
	while (GetMessage(&msg, NULL, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
	return (int)msg.wParam;
}
*********************************调用演示************************************/
